[1mdiff --git a/src/include/primer/p0_trie.h b/src/include/primer/p0_trie.h[m
[1mindex dcad218..ce74626 100644[m
[1m--- a/src/include/primer/p0_trie.h[m
[1m+++ b/src/include/primer/p0_trie.h[m
[36m@@ -12,14 +12,15 @@[m
 [m
 #pragma once[m
 [m
[32m+[m[32m#include <bits/stdc++.h>[m
[32m+[m[32m#include <functional>[m
 #include <memory>[m
 #include <stdexcept>[m
 #include <string>[m
 #include <unordered_map>[m
 #include <utility>[m
 #include <vector>[m
[31m-#include <functional>[m
[31m-#include <bits/stdc++.h>[m
[32m+[m
 #include "common/exception.h"[m
 #include "common/rwlatch.h"[m
 [m
[36m@@ -38,11 +39,7 @@[m [mclass TrieNode {[m
    *[m
    * @param key_char Key character of this trie node[m
    */[m
[31m-  explicit TrieNode(char key_char) [m
[31m-  :key_char_(key_char),[m
[31m-  is_end_(false)[m
[31m-  {}[m
[31m-[m
[32m+[m[32m  explicit TrieNode(char key_char) : key_char_(key_char) {}[m
 [m
   /**[m
    * TODO(P0): Add implementation[m
[36m@@ -53,10 +50,9 @@[m [mclass TrieNode {[m
    * @param other_trie_node Old trie node.[m
    */[m
   TrieNode(TrieNode &&other_trie_node) noexcept[m
[31m-    :key_char_(other_trie_node.key_char_),[m
[31m-    is_end_(other_trie_node.is_end_),[m
[31m-    children_(std::move(other_trie_node.children_)) {}[m
[31m- [m
[32m+[m[32m      : key_char_(other_trie_node.key_char_),[m
[32m+[m[32m        is_end_(other_trie_node.is_end_),[m
[32m+[m[32m        children_(std::move(other_trie_node.children_)) {}[m
 [m
   /**[m
    * @brief Destroy the TrieNode object.[m
[36m@@ -71,9 +67,7 @@[m [mclass TrieNode {[m
    * @param key_char Key char of child node.[m
    * @return True if this trie node has a child with given key, false otherwise.[m
    */[m
[31m-  bool HasChild(char key_char) const {[m
[31m-    return children_.find(key_char) != children_.end();[m
[31m-  }[m
[32m+[m[32m  bool HasChild(char key_char) const { return children_.find(key_char) != children_.end(); }[m
 [m
   /**[m
    * TODO(P0): Add implementation[m
[36m@@ -83,9 +77,7 @@[m [mclass TrieNode {[m
    *[m
    * @return True if this trie node has any child node, false if it has no child node.[m
    */[m
[31m-  bool HasChildren() const {[m
[31m-    return !children_.empty();[m
[31m-    }[m
[32m+[m[32m  bool HasChildren() const { return !children_.empty(); }[m
 [m
   /**[m
    * TODO(P0): Add implementation[m
[36m@@ -124,13 +116,13 @@[m [mclass TrieNode {[m
    * @param child Unique pointer created for the child node. This should be added to children_ map.[m
    * @return Pointer to unique_ptr of the inserted child node. If insertion fails, return nullptr.[m
    */[m
[31m-  std::unique_ptr<TrieNode> *InsertChildNode(char key_char, std::unique_ptr<TrieNode> &&child) { [m
[31m-    if(key_char==child->GetKeyChar() && children_.find(key_char)==children_.end()){[m
[32m+[m[32m  std::unique_ptr<TrieNode> *InsertChildNode(char key_char, std::unique_ptr<TrieNode> &&child) {[m
[32m+[m[32m    if (key_char == child->GetKeyChar() && children_.find(key_char) == children_.end()) {[m
       children_[key_char] = std::move(child);[m
       return &children_[key_char];[m
     }[m
[31m-    return nullptr; [m
[31m-    }[m
[32m+[m[32m    return nullptr;[m
[32m+[m[32m  }[m
 [m
   /**[m
    * TODO(P0): Add implementation[m
[36m@@ -142,8 +134,8 @@[m [mclass TrieNode {[m
    * @return Pointer to unique_ptr of the child node, nullptr if child[m
    *         node does not exist.[m
    */[m
[31m-  std::unique_ptr<TrieNode> *GetChildNode(char key_char) { [m
[31m-    if(!HasChild(key_char)) {[m
[32m+[m[32m  std::unique_ptr<TrieNode> *GetChildNode(char key_char) {[m
[32m+[m[32m    if (!HasChild(key_char)) {[m
       return nullptr;[m
     }[m
     return &children_[key_char];[m
[36m@@ -158,7 +150,7 @@[m [mclass TrieNode {[m
    * @param key_char Key char of child node to be removed[m
    */[m
   void RemoveChildNode(char key_char) {[m
[31m-    if(children_.find(key_char) != children_.end()){[m
[32m+[m[32m    if (children_.find(key_char) != children_.end()) {[m
       children_[key_char].reset();[m
       children_.erase(key_char);[m
     }[m
[36m@@ -176,7 +168,7 @@[m [mclass TrieNode {[m
    *[m
    * @param is_end Whether this trie node is ending char of a key string[m
    */[m
[31m-  void SetEndNode(bool is_end) { is_end_=is_end; }[m
[32m+[m[32m  void SetEndNode(bool is_end) { is_end_ = is_end; }[m
 [m
  protected:[m
   /** Key character of this trie node */[m
[36m@@ -217,10 +209,7 @@[m [mclass TrieNodeWithValue : public TrieNode {[m
    * @param trieNode TrieNode whose data is to be moved to TrieNodeWithValue[m
    * @param value[m
    */[m
[31m-  TrieNodeWithValue(TrieNode &&trieNode, T value) [m
[31m-  :TrieNode(std::move(trieNode)),[m
[31m-    value_(value)[m
[31m-  {is_end_ = true;}[m
[32m+[m[32m  TrieNodeWithValue(TrieNode &&trieNode, T value) : TrieNode(std::move(trieNode)), value_(value) { is_end_ = true; }[m
 [m
   /**[m
    * TODO(P0): Add implementation[m
[36m@@ -235,10 +224,7 @@[m [mclass TrieNodeWithValue : public TrieNode {[m
    * @param key_char Key char of this node[m
    * @param value Value of this node[m
    */[m
[31m-  TrieNodeWithValue(char key_char, T value) [m
[31m-  :TrieNode(key_char),[m
[31m-    value_(value)[m
[31m-  {is_end_ = true;}[m
[32m+[m[32m  TrieNodeWithValue(char key_char, T value) : TrieNode(key_char), value_(value) { is_end_ = true; }[m
 [m
   /**[m
    * @brief Destroy the Trie Node With Value object[m
[36m@@ -302,33 +288,36 @@[m [mclass Trie {[m
   template <typename T>[m
   bool Insert(const std::string &key, T value) {[m
     bool ret = false;[m
[31m-    if(key.empty()) return false;[m
[32m+[m[32m    if (key.empty()) {[m
[32m+[m[32m      return false;[m
[32m+[m[32m    }[m
     latch_.RLock();[m
     std::unique_ptr<TrieNode> *node = &root_;[m
     int i = 0;[m
     int n = key.size();[m
[31m-    for(i = 0; i<n-1; i++) {[m
[31m-      if(node->get()->GetChildNode(key[i])==nullptr){[m
[32m+[m[32m    for (i = 0; i < n - 1; i++) {[m
[32m+[m[32m      if (node->get()->GetChildNode(key[i]) == nullptr) {[m
         node->get()->InsertChildNode(key[i], std::move(std::make_unique<TrieNode>(key[i])));[m
       }[m
[31m-      //printf("%d %c\n", i, key[i]);[m
[32m+[m[32m      // printf("%d %c\n", i, key[i]);[m
       node = node->get()->GetChildNode(key[i]);[m
     }[m
     char ch = key[key.length() - 1];[m
     std::unique_ptr<TrieNode> *terminal_node = node->get()->GetChildNode(ch);[m
[31m-    //ÊúÄÂêé‰∏Ä‰∏™Â≠óÁ¨¶[m
[31m-    if(terminal_node==nullptr){[m
[31m-      //Â¶ÇÊûúÊ≤°ÊúâÂ≠êËäÇÁÇπÂàôÂàõÂª∫ÁªàÊú´ÁªìËäÇÁÇπÊèíÂÖ•[m
[31m-      node->get()->InsertChildNode(ch, std::move(std::make_unique<TrieNodeWithValue<T>>(ch,value)));[m
[32m+[m[32m    // ÊúÄÂêé‰∏Ä‰∏™Â≠óÁ¨¶[m
[32m+[m[32m    if (terminal_node == nullptr) {[m
[32m+[m[32m      // Â¶ÇÊûúÊ≤°ÊúâÂ≠êËäÇÁÇπÂàôÂàõÂª∫ÁªàÊú´ÁªìËäÇÁÇπÊèíÂÖ•[m
[32m+[m[32m      node->get()->InsertChildNode(ch, std::move(std::make_unique<TrieNodeWithValue<T>>(ch, value)));[m
       node->get()->SetEndNode(false);[m
       ret = true;[m
[31m-    }else if(!terminal_node->get()->IsEndNode()){[m
[31m-      //Â¶ÇÊûúÊúâÈùûÁªàÊú´ËäÇÁÇπÂàôÂº∫Âà∂Êîπ‰∏∫ÁªàËäÇÁÇπ[m
[31m-      //printf("Â¶ÇÊûúÊúâÈùûÁªàÊú´ËäÇÁÇπÂàôÂº∫Âà∂Êîπ‰∏∫ÁªàËäÇÁÇπ\n");[m
[31m-      node->get()->InsertChildNode(ch, std::move(std::make_unique<TrieNodeWithValue<T>>(std::move(**terminal_node),value)));[m
[32m+[m[32m    } else if (!terminal_node->get()->IsEndNode()) {[m
[32m+[m[32m      // Â¶ÇÊûúÊúâÈùûÁªàÊú´ËäÇÁÇπÂàôÂº∫Âà∂Êîπ‰∏∫ÁªàËäÇÁÇπ[m
[32m+[m[32m      // printf("Â¶ÇÊûúÊúâÈùûÁªàÊú´ËäÇÁÇπÂàôÂº∫Âà∂Êîπ‰∏∫ÁªàËäÇÁÇπ\n");[m
[32m+[m[32m      node->get()->InsertChildNode([m
[32m+[m[32m          ch, std::move(std::make_unique<TrieNodeWithValue<T>>(std::move(**terminal_node), value)));[m
       ret = true;[m
[31m-    }else{[m
[31m-      //Â¶ÇÊûúÊúâÁªàÊú´ËäÇÁÇπÔºå‰∏ç‰ΩúÊìç‰ΩúÔºåËøîÂõûÈîôËØØ[m
[32m+[m[32m    } else {[m
[32m+[m[32m      // Â¶ÇÊûúÊúâÁªàÊú´ËäÇÁÇπÔºå‰∏ç‰ΩúÊìç‰ΩúÔºåËøîÂõûÈîôËØØ[m
       ret = false;[m
     }[m
     latch_.RUnlock();[m
[36m@@ -353,31 +342,34 @@[m [mclass Trie {[m
    * @return True if the key exists and is removed, false otherwise[m
    */[m
   bool Remove(const std::string &key) {[m
[31m-    if(key.empty()) return false;[m
[32m+[m[32m    if (key.empty()) {[m
[32m+[m[32m      return false;[m
[32m+[m[32m    }[m
     bool ret = false;[m
[31m-    std::function<bool(std::unique_ptr<TrieNode> *, std::string &)> dfs = [&] (std::unique_ptr<TrieNode> *node, std::string &key) -> bool{[m
[31m-      if((node == nullptr && !key.empty()) || (node != nullptr && key.empty())) return false;[m
[31m-      if(node == nullptr && key.empty()) {[m
[32m+[m[32m    std::function<bool(std::unique_ptr<TrieNode> *, std::string &)> dfs = [&](std::unique_ptr<TrieNode> *node,[m
[32m+[m[32m                                                                              std::string &key) -> bool {[m
[32m+[m[32m      if ((node == nullptr && !key.empty()) || (node != nullptr && key.empty())) return false;[m
[32m+[m[32m      if (node == nullptr && key.empty()) {[m
         return true;[m
       }[m
[31m-      //node != nullptr && key.size()!=0,ÁªßÁª≠Âêë‰∏ãÈÄíÂΩí[m
[31m-      std::string subkey = key.substr(1,key.size()-1);[m
[31m-      printf("key[0] = %c\n", key[0]);[m
[31m-      ret = dfs(node->get()->GetChildNode(key[1]),subkey);[m
[32m+[m[32m      // node != nullptr && key.size()!=0,ÁªßÁª≠Âêë‰∏ãÈÄíÂΩí[m
[32m+[m[32m      std::string subkey = key.substr(1, key.size() - 1);[m
[32m+[m[32m      // printf("key[0] = %c\n", key[0]);[m
[32m+[m[32m      ret = dfs(node->get()->GetChildNode(key[1]), subkey);[m
 [m
[31m-      if(!ret) return false;[m
[31m-      if(key.size()==1) {[m
[31m-        if(node->get()->IsEndNode()) {[m
[31m-          printf("22222\n");[m
[32m+[m[32m      if (!ret) return false;[m
[32m+[m[32m      if (key.size() == 1) {[m
[32m+[m[32m        if (node->get()->IsEndNode()) {[m
[32m+[m[32m          // printf("22222\n");[m
           node->get()->SetEndNode(false);[m
           return true;[m
[31m-        }else {[m
[32m+[m[32m        } else {[m
           return false;[m
         }[m
       }[m
[31m-      if(node->get()->GetChildNode(key[1])!=nullptr && !(node->get()->GetChildNode(key[1])->get()->HasChildren())) {[m
[31m-        //ÂΩìÊâæÂà∞‰∫ÜÂπ∂‰∏îÂ≠êËäÇÁÇπÊ≤°ÊúâÂ≠êËäÇÁÇπÔºåÈÇ£Â∞±Âà†Èô§Â≠êËäÇÁÇπ[m
[31m-        printf("remove chiled node\n");[m
[32m+[m[32m      if (node->get()->GetChildNode(key[1]) != nullptr && !(node->get()->GetChildNode(key[1])->get()->HasChildren())) {[m
[32m+[m[32m        // ÂΩìÊâæÂà∞‰∫ÜÂπ∂‰∏îÂ≠êËäÇÁÇπÊ≤°ÊúâÂ≠êËäÇÁÇπÔºåÈÇ£Â∞±Âà†Èô§Â≠êËäÇÁÇπ[m
[32m+[m[32m        // printf("remove chiled node\n");[m
         node->get()->RemoveChildNode(key[1]);[m
       }[m
       return true;[m
[36m@@ -386,7 +378,7 @@[m [mclass Trie {[m
     auto node = &root_;[m
     ret = dfs(node->get()->GetChildNode(key[0]), const_cast<std::string &>(key));[m
     latch_.RUnlock();[m
[31m-    printf("-----------------\n");[m
[32m+[m[32m    // printf("-----------------\n");[m
     return ret;[m
   }[m
 [m
[36m@@ -411,19 +403,19 @@[m [mclass Trie {[m
   template <typename T>[m
   T GetValue(const std::string &key, bool *success) {[m
     *success = false;[m
[31m-    if(key.empty()) return {};[m
[32m+[m[32m    if (key.empty()) return {};[m
     std::unique_ptr<TrieNode> *node = &root_;[m
     latch_.RLock();[m
[31m-    for(char c:key) {[m
[32m+[m[32m    for (char c : key) {[m
       node = node->get()->GetChildNode(c);[m
[31m-      if(node == nullptr){[m
[32m+[m[32m      if (node == nullptr) {[m
         latch_.RUnlock();[m
         return {};[m
       }[m
     }[m
     T res;[m
     auto flag_node = dynamic_cast<TrieNodeWithValue<T> *>(node->get());[m
[31m-    if(flag_node == nullptr) {[m
[32m+[m[32m    if (flag_node == nullptr) {[m
       res = {};[m
     }[m
     *success = true;[m
